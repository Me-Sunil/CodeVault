package com.Projectile;

import com.Constants.GeoConstants;

import Bean.Projectile_Trajectory;

public class Projectile_Calculation {

	public float get_range_ms(float initial_velocity, float launch_degree) {

		// R = (v*v)*Sin(2*ø)/g

		launch_degree = (float) ((float) launch_degree * Math.PI / 180);
		return (float) ((initial_velocity * initial_velocity) * Math.sin((2 * launch_degree))
				/ GeoConstants.gravity_ms);
	}

	public float get_max_height_ms(float initial_velocity, float launch_degree) {
		// H = (v*v)*pow(sin(ø),2)/2*g;
		launch_degree = (float) ((float) launch_degree * Math.PI / 180);
		return (float) (initial_velocity * initial_velocity * Math.pow(Math.sin(launch_degree), 2)
				/ (2 * GeoConstants.gravity_ms));
	}

	public float get_time_to_reach_max_height(float initial_velocity, float launch_degree) {
//		hmax = h + V₀² * sin(α)² / (2 * g)
		launch_degree = (float) ((float) launch_degree * Math.PI / 180);
		return (float) (initial_velocity * Math.sin(launch_degree) / GeoConstants.gravity_ms);
	}

	public float get_time_of_flight(float initial_velocity, float launch_degree) {
//		t = 2 * V₀ * sin(α) / g
		return (float) 2 * get_time_to_reach_max_height(initial_velocity, launch_degree);
	}

	public float[] get_trajectory_ms(float initial_velocity, float launch_degree, float height_of_projectile) {
		// y = h + xtan(α) - gx²/2V₀²cos²(α)
		// y - Height of Projectile
		// x - Range at Point

		Projectile_Trajectory[] rangeCal = new Projectile_Trajectory[10];
		return rangeCal;
	}
}
